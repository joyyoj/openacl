/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef OpenAcl_TYPES_H
#define OpenAcl_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>





struct UserType {
  enum type {
    kManagered = 0,
    kExternal = 1
  };
};

extern const std::map<int, const char*> _UserType_VALUES_TO_NAMES;

struct RoleType {
  enum type {
    kPrivate = 0,
    kProtected = 1,
    kPublic = 2
  };
};

extern const std::map<int, const char*> _RoleType_VALUES_TO_NAMES;

struct PrivilegeType {
  enum type {
    kList = 0,
    kRead = 1,
    kWrite = 2
  };
};

extern const std::map<int, const char*> _PrivilegeType_VALUES_TO_NAMES;

struct AuditLevel {
  enum type {
    kTrace = 0,
    kInfo = 1,
    kCritical = 2
  };
};

extern const std::map<int, const char*> _AuditLevel_VALUES_TO_NAMES;

typedef std::map<std::string, std::string>  Properties;


class User {
 public:

  static const char* ascii_fingerprint; // = "D6FD826D949221396F4FFC3ECCD3D192";
  static const uint8_t binary_fingerprint[16]; // = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

  User() : name(), type((UserType::type)0) {
  }

  virtual ~User() throw() {}

  std::string name;
  UserType::type type;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_type(const UserType::type val) {
    type = val;
  }

  bool operator == (const User & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const User &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const User & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(User &a, User &b);

typedef struct _Role__isset {
  _Role__isset() : type(false) {}
  bool type;
} _Role__isset;

class Role {
 public:

  static const char* ascii_fingerprint; // = "D6FD826D949221396F4FFC3ECCD3D192";
  static const uint8_t binary_fingerprint[16]; // = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

  Role() : name(), type((RoleType::type)0) {
  }

  virtual ~Role() throw() {}

  std::string name;
  RoleType::type type;

  _Role__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_type(const RoleType::type val) {
    type = val;
  }

  bool operator == (const Role & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const Role &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Role & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Role &a, Role &b);

typedef struct _Entity__isset {
  _Entity__isset() : scheme(false), path(false), query(false) {}
  bool scheme;
  bool path;
  bool query;
} _Entity__isset;

class Entity {
 public:

  static const char* ascii_fingerprint; // = "AB879940BD15B6B25691265F7384B271";
  static const uint8_t binary_fingerprint[16]; // = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

  Entity() : scheme(), path(), query() {
  }

  virtual ~Entity() throw() {}

  std::string scheme;
  std::string path;
  std::string query;

  _Entity__isset __isset;

  void __set_scheme(const std::string& val) {
    scheme = val;
  }

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_query(const std::string& val) {
    query = val;
  }

  bool operator == (const Entity & rhs) const
  {
    if (!(scheme == rhs.scheme))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(query == rhs.query))
      return false;
    return true;
  }
  bool operator != (const Entity &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Entity & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Entity &a, Entity &b);

typedef struct _Privilege__isset {
  _Privilege__isset() : type(false), entities(false) {}
  bool type;
  bool entities;
} _Privilege__isset;

class Privilege {
 public:

  static const char* ascii_fingerprint; // = "D06284C2D95226CFE98D81614AD00472";
  static const uint8_t binary_fingerprint[16]; // = {0xD0,0x62,0x84,0xC2,0xD9,0x52,0x26,0xCF,0xE9,0x8D,0x81,0x61,0x4A,0xD0,0x04,0x72};

  Privilege() : type((PrivilegeType::type)0) {
  }

  virtual ~Privilege() throw() {}

  PrivilegeType::type type;
  std::vector<Entity>  entities;

  _Privilege__isset __isset;

  void __set_type(const PrivilegeType::type val) {
    type = val;
  }

  void __set_entities(const std::vector<Entity> & val) {
    entities = val;
  }

  bool operator == (const Privilege & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(entities == rhs.entities))
      return false;
    return true;
  }
  bool operator != (const Privilege &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Privilege & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Privilege &a, Privilege &b);

typedef struct _AuthStatus__isset {
  _AuthStatus__isset() : code(false), message(false) {}
  bool code;
  bool message;
} _AuthStatus__isset;

class AuthStatus {
 public:

  static const char* ascii_fingerprint; // = "3F5FC93B338687BC7235B1AB103F47B3";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

  AuthStatus() : code(0), message() {
  }

  virtual ~AuthStatus() throw() {}

  int32_t code;
  std::string message;

  _AuthStatus__isset __isset;

  void __set_code(const int32_t val) {
    code = val;
  }

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const AuthStatus & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const AuthStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AuthStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AuthStatus &a, AuthStatus &b);

typedef struct _UserInfo__isset {
  _UserInfo__isset() : user(false), token(false), properties(false) {}
  bool user;
  bool token;
  bool properties;
} _UserInfo__isset;

class UserInfo {
 public:

  static const char* ascii_fingerprint; // = "9A636D2026176178B1336D7368BC8182";
  static const uint8_t binary_fingerprint[16]; // = {0x9A,0x63,0x6D,0x20,0x26,0x17,0x61,0x78,0xB1,0x33,0x6D,0x73,0x68,0xBC,0x81,0x82};

  UserInfo() : token() {
  }

  virtual ~UserInfo() throw() {}

  User user;
  std::string token;
  Properties properties;

  _UserInfo__isset __isset;

  void __set_user(const User& val) {
    user = val;
  }

  void __set_token(const std::string& val) {
    token = val;
  }

  void __set_properties(const Properties& val) {
    properties = val;
  }

  bool operator == (const UserInfo & rhs) const
  {
    if (!(user == rhs.user))
      return false;
    if (!(token == rhs.token))
      return false;
    if (!(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const UserInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UserInfo &a, UserInfo &b);

typedef struct _RoleInfo__isset {
  _RoleInfo__isset() : role(false), properties(false) {}
  bool role;
  bool properties;
} _RoleInfo__isset;

class RoleInfo {
 public:

  static const char* ascii_fingerprint; // = "B1612382BC1ED940DF7F9F8EA64DEB04";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0x61,0x23,0x82,0xBC,0x1E,0xD9,0x40,0xDF,0x7F,0x9F,0x8E,0xA6,0x4D,0xEB,0x04};

  RoleInfo() {
  }

  virtual ~RoleInfo() throw() {}

  Role role;
  Properties properties;

  _RoleInfo__isset __isset;

  void __set_role(const Role& val) {
    role = val;
  }

  void __set_properties(const Properties& val) {
    properties = val;
  }

  bool operator == (const RoleInfo & rhs) const
  {
    if (!(role == rhs.role))
      return false;
    if (!(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const RoleInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RoleInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(RoleInfo &a, RoleInfo &b);

typedef struct _PrivilegeList__isset {
  _PrivilegeList__isset() : entity(false) {}
  bool entity;
} _PrivilegeList__isset;

class PrivilegeList {
 public:

  static const char* ascii_fingerprint; // = "636807D016867BC3A79FD54005E0677E";
  static const uint8_t binary_fingerprint[16]; // = {0x63,0x68,0x07,0xD0,0x16,0x86,0x7B,0xC3,0xA7,0x9F,0xD5,0x40,0x05,0xE0,0x67,0x7E};

  PrivilegeList() {
  }

  virtual ~PrivilegeList() throw() {}

  Entity entity;

  _PrivilegeList__isset __isset;

  void __set_entity(const Entity& val) {
    entity = val;
  }

  bool operator == (const PrivilegeList & rhs) const
  {
    if (!(entity == rhs.entity))
      return false;
    return true;
  }
  bool operator != (const PrivilegeList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrivilegeList & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PrivilegeList &a, PrivilegeList &b);

typedef struct _AuditInfo__isset {
  _AuditInfo__isset() : date(false), detail(false) {}
  bool date;
  bool detail;
} _AuditInfo__isset;

class AuditInfo {
 public:

  static const char* ascii_fingerprint; // = "837A3E976771ACA22191592E21BCA18C";
  static const uint8_t binary_fingerprint[16]; // = {0x83,0x7A,0x3E,0x97,0x67,0x71,0xAC,0xA2,0x21,0x91,0x59,0x2E,0x21,0xBC,0xA1,0x8C};

  AuditInfo() : level((AuditLevel::type)0), user(), action(), entity(), date() {
  }

  virtual ~AuditInfo() throw() {}

  AuditLevel::type level;
  std::string user;
  std::string action;
  std::string entity;
  std::string date;
  Properties detail;

  _AuditInfo__isset __isset;

  void __set_level(const AuditLevel::type val) {
    level = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_action(const std::string& val) {
    action = val;
  }

  void __set_entity(const std::string& val) {
    entity = val;
  }

  void __set_date(const std::string& val) {
    date = val;
    __isset.date = true;
  }

  void __set_detail(const Properties& val) {
    detail = val;
    __isset.detail = true;
  }

  bool operator == (const AuditInfo & rhs) const
  {
    if (!(level == rhs.level))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(action == rhs.action))
      return false;
    if (!(entity == rhs.entity))
      return false;
    if (__isset.date != rhs.__isset.date)
      return false;
    else if (__isset.date && !(date == rhs.date))
      return false;
    if (__isset.detail != rhs.__isset.detail)
      return false;
    else if (__isset.detail && !(detail == rhs.detail))
      return false;
    return true;
  }
  bool operator != (const AuditInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AuditInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AuditInfo &a, AuditInfo &b);

typedef struct _AuditCriteria__isset {
  _AuditCriteria__isset() : condition(false), offset(false), limit(false), order(false) {}
  bool condition;
  bool offset;
  bool limit;
  bool order;
} _AuditCriteria__isset;

class AuditCriteria {
 public:

  static const char* ascii_fingerprint; // = "117811434B043EA39B98AC2A3E784934";
  static const uint8_t binary_fingerprint[16]; // = {0x11,0x78,0x11,0x43,0x4B,0x04,0x3E,0xA3,0x9B,0x98,0xAC,0x2A,0x3E,0x78,0x49,0x34};

  AuditCriteria() : condition(), offset(0), limit(0), order() {
  }

  virtual ~AuditCriteria() throw() {}

  std::string condition;
  int32_t offset;
  int32_t limit;
  std::string order;

  _AuditCriteria__isset __isset;

  void __set_condition(const std::string& val) {
    condition = val;
  }

  void __set_offset(const int32_t val) {
    offset = val;
  }

  void __set_limit(const int32_t val) {
    limit = val;
  }

  void __set_order(const std::string& val) {
    order = val;
  }

  bool operator == (const AuditCriteria & rhs) const
  {
    if (!(condition == rhs.condition))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(limit == rhs.limit))
      return false;
    if (!(order == rhs.order))
      return false;
    return true;
  }
  bool operator != (const AuditCriteria &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AuditCriteria & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AuditCriteria &a, AuditCriteria &b);



#endif
